<article class="markdown-body">
<p><link href='https://fonts.googleapis.com/css?family=Caveat' rel='stylesheet'><br />
<link rel="stylesheet" href="css/github-markdown.css"><br />
<link rel="stylesheet" href="css/projects.css"><br />
<link rel="stylesheet" href="css//intellij-light.min.css"></p>
<script src="js/highlight-11.6.0.min.js"></script>
<script>
function showDialog(id) {
  document.getElementById(id).showModal();
  document.documentElement.style.overflowY = 'hidden';
  return false; // to disable href
}

function hideDialog(id)  {
  document.getElementById(id).close();
  document.documentElement.style.overflowY = '';
  return false; // to disable href
}

function clickTab(e) {
  console.log(e);
  let tabSpan = e.target;
  let tabHeader = tabSpan.parentElement;
  let tabBody = tabHeader.nextElementSibling;
  console.log("tabBody");
  console.log(tabBody);
  for(let i = 0; i < tabHeader.children.length; i++) {
    if(tabSpan == tabHeader.children[i]) {
      console.log("Clicked tab " + i);
      tabHeader.children[i].classList.add('selected');
      tabBody.children[i].classList.add('selected');
    } else {
      console.log("Did not click tab " + i);
      tabHeader.children[i].classList.remove('selected');
      tabBody.children[i].classList.remove('selected');
    }
  }
}
</script>
<style>
.markdown-body h1 {
  font-family: 'Caveat';
  font-size: 40;
  background-color: #183d3d;
  color: white;
  padding: 40px;
}

.markdown-body h2 {
  margin-top: 3em;
}

.markdown-body img {
  margin: 50px;
}

.tab-header span {
  padding-left: 10px;
  padding-right: 10px;
  padding-bottom: 2px;
  border-left: 1px solid white;
  border-right: 1px solid white;
  cursor: pointer;
  color: white;
  background-color: rgb(70, 70, 70);
  border-top: none;
}

.tab-header span.selected {
  background-color: var(--color-canvas-subtle);
  color: black;
  border-top: 2px solid cornflowerblue;
}

.tab-content {
  display: none;
}

.tab-content.selected {
  display: block;
}

/*
table {
  width:100%;
}
table td {
  padding-top: 1em;
  padding-bottom: 1em;
}
*/

dialog {
  max-width: 800px;
  max-height: calc(100vh - 150px);
  overflow-y: auto;
  border-width: 0px;
  box-shadow: 0px 0px 15px;
}

dialog::backdrop {
  background-color: #000000a0;
}

details summary {
  display: block;
}

.content {
  background-color: #f5f5f5;
  margin: 1em;
  margin-right: 0px;
  padding: 10px;
  padding-bottom: 1px;
  font-size: smaller;
  border-radius: 5px;
}

@keyframes details-show {
  from {
    opacity:0;
    transform: var(--details-translate, translateY(-0.5em));
  }
}

details[open] > *:not(summary) {
  animation: details-show 150ms ease-in-out;
}

/*
table th:first-of-type {
  width:20%
}
table th:nth-of-type(2) {
  width:10%
}
table th:nth-of-type(3) {
  width:40%
}
table th:nth-of-type(4) {
  width:30%
}
*/

</style>
<h1 id="natural-language-scripting-a-first-tutorialbr-image-pre-processing">Natural Language Scripting: A first tutorial<br> Image Pre-processing</h1>
<h2 id="why-use-a-natural-scripting-interface">Why use a natural scripting interface</h2>
<p>Graphical user interfaces can easily become complex and confusing as the number of user input parameters increases. This is particularly true if a workflow needs to be configured, where (i) each step has its own set of parameters, (ii) steps can occur in any order and (iii) steps can be repeated arbitrarily. Consider the configuration of an image pre-processing workflow, which consists of the following algorithms, each having its own set of parameters:</p>
<ul>
<li>Gaussian blurring (standard deviation)</li>
<li>Median filtering (window radius)</li>
<li>Background subtraction (window radius)</li>
<li>Conversion to grayscale</li>
<li>Intensity normalization</li>
</ul>
<p>A traditional graphical user interface (GUI) could e.g. look like this:</p>
<p><img src="images/Screenshot-00.png" alt="" /></p>
<p>where the user can activate the various algorithms and specify their parameters as necessary. This user interface however does not take into account that different algorithms could occur repeatedly, and it does not allow to change the order.</p>
<p>Using Natural Language Scripting, we want to implement a text-based interface which reads and executes text like:</p>
<pre><code class="hljs bash language-bash">Apply Gaussian blurring with a standard deviation of 3 pixel(s).
Subtract the background with a window readius of 30 pixel(s).
Apply Median filtering with a window radius of 1 pixel(s).
Normalize intensities.
Apply Gaussian blurring with a standard deviation of 1 pixel(s).</code></pre>
<h2 id="create-the-backend">Create the backend</h2>
<p>First of all, we'll implement a backend which does the actual processing. We therefore create a class that implements the actual algorithms. It uses Fiji as an underlying image processing library:<br />
<details><summary><b>Preprocessing.java</b></summary></p>
<pre><code class="hljs"><span class="hljs-keyword">import</span> ij.IJ;
<span class="hljs-keyword">import</span> ij.ImagePlus;
<span class="hljs-keyword">import</span> ij.process.ImageProcessor;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Preprocessing</span> {

    <span class="hljs-keyword">private</span> ImagePlus image;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Preprocessing</span><span class="hljs-params">(ImagePlus image)</span> </span>{
        <span class="hljs-keyword">this</span>.image = image;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">gaussianBlur</span><span class="hljs-params">(<span class="hljs-type">float</span> stdDev)</span> </span>{
        IJ.<span class="hljs-built_in">run</span>(image, <span class="hljs-string">&quot;Gaussian Blur...&quot;</span>, <span class="hljs-string">&quot;sigma=&quot;</span> + stdDev);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">medianFilter</span><span class="hljs-params">(<span class="hljs-type">int</span> radius)</span> </span>{
        IJ.<span class="hljs-built_in">run</span>(image, <span class="hljs-string">&quot;Median...&quot;</span>, <span class="hljs-string">&quot;radius=&quot;</span> + radius);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">subtractBackground</span><span class="hljs-params">(<span class="hljs-type">float</span> radius)</span> </span>{
        IJ.<span class="hljs-built_in">run</span>(image, <span class="hljs-string">&quot;Subtract Background...&quot;</span>, <span class="hljs-string">&quot;rolling=50&quot;</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">convertToGray</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span>(image.<span class="hljs-built_in">getType</span>() == ImagePlus.COLOR_RGB)
            IJ.<span class="hljs-built_in">run</span>(image, <span class="hljs-string">&quot;8-bit&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">intensityNormalization</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">convertToGray</span>();
        ImageProcessor ip = image.<span class="hljs-built_in">getProcessor</span>();
        <span class="hljs-type">double</span> min = ip.<span class="hljs-built_in">getMin</span>();
        <span class="hljs-type">double</span> max = ip.<span class="hljs-built_in">getMax</span>();
        ip = ip.<span class="hljs-built_in">convertToFloat</span>();
        ip.<span class="hljs-built_in">subtract</span>(min);
        ip.<span class="hljs-built_in">multiply</span>(<span class="hljs-number">1</span> / (max - min));
        image.<span class="hljs-built_in">setProcessor</span>(ip);
    }
}
</code></pre>
<p></details></p>
<h2 id="implement-an-interface-that-understands-a-first-sentence">Implement an interface that understands a first sentence</h2>
<p>The Natural Language Scripting framework offers a convenient way to define the sentences your interface should understand, and provides an auto-completion enabled text editor for users to enter their instructions. The following code snippet shows how to create a parser, how to define a pattern for a sentence for it to parse, and how to display the editor:</p>
<div class="tab-header"><span>Java</span><span class="selected">Python</span><span>JavaScript</span></div>
<div class="tab-body">
<div class="tab-content selected"><pre><code class="hljs java language-java"><span class="hljs-type">Parser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parser</span>();
parser.defineSentence(
    <span class="hljs-string">&quot;Apply Gaussian blurring with a standard deviation of {stddev:float} pixel(s).&quot;</span>,
    <span class="hljs-literal">null</span>);

<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACEditor</span>(parser).setVisible(<span class="hljs-literal">true</span>);</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs python language-python">parser = Parser();
parser.defineSentence(
    <span class="hljs-string">&quot;Apply Gaussian blurring with a standard deviation of {stddev:float} pixel(s).&quot;</span>,
    <span class="hljs-literal">None</span>);

ACEditor(parser).show();</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs javascript language-javascript">parser = nlScript.<span class="hljs-title class_">Parser</span>();
parser.<span class="hljs-title function_">defineSentence</span>(
    <span class="hljs-string">&quot;Apply Gaussian blurring with a standard deviation of {stddev:float} pixel(s).&quot;</span>,
    <span class="hljs-literal">undefined</span>);

<span class="hljs-keyword">new</span> nlScript.<span class="hljs-title class_">ACEditor</span>(parser, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;nls-container&quot;</span>));</code></pre>
</div>
</div>
<p>Find the full code here: <a href="https://github.com/nlScript/nlScript-tutorial-java/blob/main/src/main/java/nlScript/tutorial/preprocessing/Tutorial01.java"><code>Java</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-python/blob/main/tutorial01.py"><code>Python</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-js/blob/main/docs/tutorial01.html"><code>JavaScript</code></a>.</p>
<p>In this example we state that we expect a literal "Apply Gaussian blurring with a standard deviation of ", followed by a floating point number, which we name "stddev" for later reference, followed by the literal "pixel(s).". There is a second parameter to <code>defineSentence()</code>, which we'll discover next.</p>
<p>The code snippet is sufficient to provide the means for user input, but nothing happens yet when the user clicks the <code>Run</code> button.</p>
<p>Find more information about <a href="variables.html" target="_blank">How to specify variables</a>.</p>
<h2 id="evaluating-the-parsed-text">Evaluating the parsed text</h2>
<p>The second argument to <code>parser.defineSentence()</code>, which was omitted above, is of type <code>Evaluator</code>. <code>Evaluator</code> is an interface with a single function</p>
<div class="tab-header"><span>Java</span><span class="selected">Python</span><span>JavaScript</span></div>
<div class="tab-body">
<div class="tab-content selected"><pre><code class="hljs"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">Evaluator</span> {
   Object evaluate(ParsedNode pn); 
}</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs python language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IEvaluator</span>(<span class="hljs-title class_ inherited__">ABC</span>):
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">self, pn: ParsedNode</span>) -&gt; <span class="hljs-built_in">object</span>:
        <span class="hljs-keyword">pass</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Evaluator</span>(<span class="hljs-title class_ inherited__">IEvaluator</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, evaluate: <span class="hljs-type">Callable</span>[[ParsedNode], <span class="hljs-built_in">object</span>]</span>):
        self._evaluate = evaluate

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">self, pn: ParsedNode</span>) -&gt; <span class="hljs-built_in">object</span>:
        <span class="hljs-keyword">return</span> self._evaluate(pn)</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">export</span> type <span class="hljs-title class_">Evaluator</span> = <span class="hljs-function">(<span class="hljs-params">pn: ParsedNode</span>) =&gt;</span> any;</code></pre>
</div>
</div>
<p>The task of the evaluator is to evaluate the expression (the sentence) we defined on the parser. In the example, it is responsible for the actual blurring. The argument to <code>evaluate()</code>, <code>pn</code>, is of type <code>ParsedNode</code>, which can be used to retrieve the parsed value for the standard deviation.</p>
<p>Variables in nlScript are defined hierarchically (see the paragraph "Custom types and type hierarchy" below). The result of parsing is also a hierarchical tree-like structure consisting of nodes of type <code>ParsedNode</code>. The <code>ParsedNode</code> has child <code>ParsedNode</code>s representing the variables the current type consists of. The sentence above consists of a string literal "Apply Gaussian blurring with a standard deviation of", a floating-point variable called "stddev", and a string literal "pixel(s).". Therefore, the <code>ParsedNode</code> given to the sentence's <code>Evaluator</code> has three child <code>ParsedNode</code>s, which can be accessed, e.g. by name, in the <code>Evaluator</code> and evaluated recursively.</p>
<div class="tab-header"><span>Java</span><span class="selected">Python</span><span>JavaScript</span></div>
<div class="tab-body">
<div class="tab-content selected"><pre><code class="hljs java language-java"><span class="hljs-type">ImagePlus</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> IJ.openImage(<span class="hljs-string">&quot;http://imagej.net/images/clown.jpg&quot;</span>);
<span class="hljs-type">Preprocessing</span> <span class="hljs-variable">preprocessing</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preprocessing</span>(image);
<span class="hljs-type">Parser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parser</span>();
parser.defineSentence(
    <span class="hljs-string">&quot;Apply Gaussian blurring with a standard deviation of {stddev:float} pixel(s).&quot;</span>,
    pn -&gt; {
        <span class="hljs-type">double</span> <span class="hljs-variable">stdDev</span> <span class="hljs-operator">=</span> (<span class="hljs-type">double</span>)pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>);
        preprocessing.gaussianBlur((<span class="hljs-type">float</span>)stdDev);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    });

<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACEditor</span>(parser).setVisible(<span class="hljs-literal">true</span>);</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs python language-python">preprocessing = Preprocessing(<span class="hljs-literal">None</span>)
preprocessing.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;http://imagej.net/images/clown.jpg&#x27;</span>)
preprocessing.show()

parser = Parser()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluateSentence</span>(<span class="hljs-params">pn</span>):
    stddev = pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>)
    preprocessing.gaussianBlur(stddev)

parser.defineSentence(
    <span class="hljs-string">&quot;Apply Gaussian blurring with a standard deviation of {stddev:float} pixel(s).&quot;</span>,
    evaluateSentence)

editor = ACEditor(parser)
editor.show()</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> preprocessing = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preprocessing</span>(<span class="hljs-string">&quot;output&quot;</span>);

<span class="hljs-keyword">let</span> parser = <span class="hljs-keyword">new</span> nlScript.<span class="hljs-title class_">Parser</span>();
parser.<span class="hljs-title function_">defineSentence</span>(
  <span class="hljs-string">&quot;Apply Gaussian blurring with a standard deviation of {stddev:float} pixel(s).&quot;</span>,
  <span class="hljs-function"><span class="hljs-params">pn</span> =&gt;</span> {
    <span class="hljs-keyword">let</span> stdDev = pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>);
    preprocessing.<span class="hljs-title function_">gaussianBlur</span>(stdDev);
    preprocessing.<span class="hljs-title function_">show</span>(<span class="hljs-string">&quot;output&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
  });

<span class="hljs-keyword">new</span> nlScript.<span class="hljs-title class_">ACEditor</span>(parser, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;nls-container&quot;</span>));</code></pre>
</div>
</div>
<p>Find the full code here: <a href="https://github.com/nlScript/nlScript-tutorial-java/blob/main/src/main/java/nlScript/tutorial/preprocessing/Tutorial02.java"><code>Java</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-python/blob/main/tutorial02.py"><code>Python</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-js/blob/main/docs/tutorial02.html"><code>JavaScript</code></a>.</p>
<p>This is the first fully working example:</p>
<video style="margin: auto; display: block;" width="800" controls>
  <source src="images/2023-09-07-13-11-46.cropped.mp4" type="video/mp4">
</video>
<h2 id="built-in-types">Built-in types</h2>
<p>Above, we specified the type of the standard deviation parameter <code>stddev</code> to be a floating point number, using <code>{stddev:float}</code>.</p>
<p>The following tables show other available built-in types:</p>
<div>

<details>
<summary><code>int</code>: An integral number</summary>
<div class="content">
<p><em>Example:</em> <code>{page:int}</code> Defines a parameter 'page' as an integral number.</p>
<p><em>Parses e.g.: </em><code>5</code></p>
<p><em>Evaluates to: </em><b>Java:</b> <code>java.lang.Integer</code>, <b>Python:</b> <code>class 'int'</code>, <b>JavaScript:</b> <code>number</code></p>
</div>
</details>

<details>
<summary><code>float</code>: A floating-point number</summary>
<div class="content">
<p><em>Example: </em><code>{sigma:float}</code> Defines a parameter 'sigma' as a floating-point number.
<p><em>Parses e.g.: </em><code>5.3</code></p>
<p><em>Evaluates to: </em><b>Java:</b> <code>java.lang.Double</code>, <b>Python:</b> <code>class 'float'</code>, <b>JavaScript:</b> <code>number</code></p>
</div>
</details>

<details>
<summary><code>digit</code>: A character from '0' to '9'</summary>
<div class="content">
<p><em>Example: </em><code>{ch:digit}</code> Defines a parameter 'ch' as a digit.
<p><em>Parses e.g.: </em><code>3</code></p>
<p><em>Evaluates to: </em><b>Java:</b> <code>java.lang.Character</code>, <b>Python:</b> <code>class 'str'</code>, <b>JavaScript:</b> <code>string</code></p>
</div>
</details>

<details>
<summary><code>letter</code>: A character A-Z or a-z</summary>
<div class="content">
<p><em>Example: </em><code>{ch:letter}</code> Defines a parameter 'ch' as a letter.
<p><em>Parses e.g.: </em><code>b</code></p>
<p><em>Evaluates to: </em><b>Java:</b> <code>java.lang.Character</code>, <b>Python:</b> <code>class 'str'</code>, <b>JavaScript:</b> <code>string</code></p>
</div>
</details>

<details>
<summary><code>path</code>: A path within the local file system</summary>
<div class="content">
<p><em>Example: </em><code>{inputfile:path}</code> Defines a parameter 'inputfile' as a file system path.
<p><em>Parses e.g.: </em><code>'C:\Program Files'</code></p>
<p><em>Evaluates to: </em><b>Java:</b> <code>java.lang.String</code>, <b>Python:</b> <code>class 'str'</code>, <b>JavaScript:</b> <code>not implemented</code></p>
</div>
</details>

<details>
<summary><code>color</code>: A color</summary>
<div class="content">
<p><em>Example: </em><code>{text-color:color}</code> Defines a parameter 'text-color' as a color.
<p><em>Parses e.g.: </em><code>(25, 0, 233)</code> as an RGB value or one of the pre-defined colors below.</p>
<p><em>Evaluates to: </em>Integral number representing the RGB value of the color. <b>Java:</b> <code>int</code> (Conversion between <code>int</code> and <code>java.awt.Color</code> is possible using <code>new Color(int)</code> and <code>Color.toRGB()</code>) <b>Python:</b> <code>class 'int'</code> <b>JavaScript:</b> <code>number</code></p>

<p>Pre-defined colors:</p>
<ul>
<li><span style="background-color: rgb(0, 0, 0);       width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  black (0, 0, 0)
<li><span style="background-color: rgb(255, 255, 255); width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  white (255, 255, 255)
<li><span style="background-color: rgb(255, 0, 0);     width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  red (255, 0, 0)
<li><span style="background-color: rgb(255, 128, 0);   width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  orange (255, 128, 0)
<li><span style="background-color: rgb(255, 255, 0);   width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  yellow (255, 255, 0)
<li><span style="background-color: rgb(128, 255, 0);   width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  lawn green (128, 255, 0)
<li><span style="background-color: rgb(0, 255, 0);     width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  green (0, 255, 0)
<li><span style="background-color: rgb(0, 255, 180);   width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  spring green (0, 255, 180)
<li><span style="background-color: rgb(0, 255, 255);   width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  cyan (0, 255, 255)
<li><span style="background-color: rgb(0, 128, 255);   width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  azure (0, 128, 255)
<li><span style="background-color: rgb(0, 0, 255);     width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  blue (0, 0, 255)
<li><span style="background-color: rgb(128, 0, 255);   width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  violet (128, 0, 255)
<li><span style="background-color: rgb(255, 0, 255);   width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  magenta (255, 0, 255)
<li><span style="background-color: rgb(255, 0, 128);   width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  pink (255, 0, 128)
<li><span style="background-color: rgb(128, 128, 128); width: 1em; display: inline-block; height: 0.6em; border: black solid 1px;"></span>  gray (128, 128, 128)
</ul>
</div>
</details>

<details>
<summary><code>weekday</code>: Day of the week</summary>
<div class="content">
<p><em>Example: </em><code>{meeting-day:weekday}</code> Defines a parameter 'meeting-day' as a weekday.
<p><em>Parses e.g.: </em><code>Monday</code> one of the pre-defined weekdays below.</p>
<p><em>Evaluates to: </em>Integral number, starting with <code>0</code> for <code>Monday</code>. <b>Java:</b> <code>int</code> <b>Python:</b> <code>class 'int'</code> <b>JavaScript:</b> <code>number</code></p>
<p>Pre-defined weekdays:</p>
<ul>
<li>Monday (0)
<li>Tuesday (1)
<li>Wednesday (2)
<li>Thursday (3)
<li>Friday (4)
<li>Saturday (5)
<li>Sunday (6)
</ul>
</div>
</details>

<details>
<summary><code>month</code>: A month</summary>
<div class="content">
<p><em>Example: </em><code>{month-of-start:month}</code> Defines a parameter 'month-of-start' as a month.
<p><em>Parses e.g.: </em><code>January</code> one of the pre-defined months below.</p>
<p><em>Evaluates to: </em>Integral number, starting with <code>0</code> for <code>January</code>. <b>Java:</b> <code>int</code> <b>Python:</b> <code>class 'int'</code> <b>JavaScript:</b> <code>number</code></p>
<p>Pre-defined months:</p>
<ul>
<li>January (0)
<li>February (1)
<li>March (2)
<li>April (3)
<li>May (4)
<li>June (5)
<li>July (6)
<li>August (7)
<li>September (8)
<li>October (9)
<li>November (10)
<li>December (11)
</ul>
</div>
</details>

<details>
<summary><code>date</code>: A date</summary>
<div class="content">
<p><em>Example: </em><code>{date-of-birth:date}</code> Defines a parameter 'date-of-birth' as a date.
<p><em>Parses e.g.: </em><code>01 January 2020</code></p>
<p><em>Evaluates to: </em><b>Java:</b> <code>java.time.LocalDate</code> <b>Python:</b> <code>class 'datetime.date'</code> <b>JavaScript:</b> <code>Date</code></p>
</div>
</details>

<details>
<summary><code>time</code>: A time</summary>
<div class="content">
<p><em>Example: </em><code>{alarm:time}</code> Defines a parameter 'alarm' as a time.
<p><em>Parses e.g.: </em><code>6:30</code></p>
<p><em>Evaluates to: </em><b>Java:</b> <code>java.time.LocalTime</code> <b>Python:</b> <code>class 'datetime.time'</code> <b>JavaScript:</b> <code>Date</code></p>
</div>
</details>

<details>
<summary><code>datetime</code>: A date and time</summary>
<div class="content">
<p><em>Example: </em><code>{meeting-start:datetime}</code> Defines a parameter 'meeting-start' as a date and time.
<p><em>Parses e.g.: </em><code>01 January 2020 14:30</code></p>
<p><em>Evaluates to: </em><b>Java:</b> <code>java.time.LocalDateTime</code> <b>Python:</b> <code>class 'datetime.datetime'</code> <b>JavaScript:</b> <code>Date</code></p>
</div>
</details>

<details>
<summary><code>tuple&lt;type,n1,n2,...&gt;</code>: An n-dimensional tuple of comma-separated elements surrounded by <code>(</code>, <code>)</code></summary>
<div class="content">
<p><em>Example: </em><code>{point:tuple&lt;int,x,y&gt;}</code> Defines a parameter 'point' as a 2-tuple with entries named 'x' and 'y', the type of which is <code>int</code></p>
<p><em>Parses e.g.: </em><code>(15, 30)</code></p>
<p><em>Evaluates to: </em><b>Java:</b> <code>java.lang.Object[]</code>. The actual type of each entry depends on <code>type</code> (In the example, the type is <code>int</code>, so each entry in the array is a <code>java.lang.Integer</code>).<b>Python:</b> <code>class 'list'</code> <b>JavaScript:</b> <code>Array</code></p>
<p><code>type</code> can also be a custom-defined type (see below)</p>
</div>
</details>

<details>
<summary><code>list&lt;type&gt;</code>: An (unbound) comma-separated list</summary>
<div class="content">
<p><em>Example: </em><code>{colors:list&lt;color&gt;}</code> Defines a parameter 'colors' as a list with entries of type <code>color</code>.</p>
<p><em>Parses e.g.: </em><code>green, blue, yellow, (255, 30, 20)</code></p>
<p><em>Evaluates to: </em><b>Java:</b> <code>java.lang.Object[]</code>. The actual type of each entry depends on <code>type</code> (In the example, the type is <code>color</code>, so each entry in the array is a <code>java.lang.Integer</code>)<b>Python:</b> <code>class 'list'</code> <b>JavaScript:</b> <code>Array</code></p>
<p><code>type</code> can also be a custom-defined type (see below)</p>

<p>Furthermore, the cardinality of a list can be constrained:<p>
<ul>
<li><code>{colors:list&lt;color&gt;:5}</code> accepts only lists with exactly 5 colors
<li><code>{colors:list&lt;color&gt;:3-5}</code> accepts only lists with 3 to 5 colors
<li><code>{colors:list&lt;color&gt;:\*}</code> accepts lists with 0 to infinity colors
<li><code>{colors:list&lt;color&gt;:+}</code> accepts lists with 1 to infinity colors
<li><code>{colors:list&lt;color&gt;:?}</code> accepts lists with 0 or 1 colors
</ul>
</div>
</details>

<details>
<summary>Character class like <code>[a-zA-Z]</code>: A definable character</summary>
<div class="content">
<p><em>Example: (1) </em><code>{ch1:[a-z0-9]}</code> or (2) <code>{ch2:[^0-9]}</code></p>
<p><em>Parses: </em> (1) Any lower-case letter or digit and (2) any character that is not a digit</p>
<p>Evaluates to: <b>Java:</b> <code>java.lang.Character</code>. <b>Python:</b> <code>class 'str'</code> <b>JavaScript:</b> <code>string</code>. If a quantifier is used, it evaluates to <code>java.lang.Object[]</code> (<b>Java</b>), where each entry is of type <code>java.lang.Character</code>, <code>class 'list'</code> (<b>Python</b>) or <code>Array</code> (<b>JavaScript</b>). If you want to get the parsed string instead, you can use <code>ParsedNode.getParsedString()</code> instead of <code>ParsedNode.evaluate()</code>. </p>
<p>Some more examples:</p>
<ul>
<li><code>[a-zAB567]</code> matches a character 'a' - 'z', 'A', 'B', '5', '6' or '7'.
<li><code>[^1-35]</code> matches any character which is not '1', '2', '3' or '5'.
</ul>

<p>Furthermore, character classes can be extended to specify strings, by specifying the number of characters to match. In this case, it evaluates to <code>java.lang.String</code>.</p>
<ul>
<li><code>{identifier:[a-z]:5}</code> accepts a string consisting of 5 lower-case letters.
<li><code>{identifier:[a-z]:3-5}</code> accepts a string consisting of 3-5 lower-case letters.
<li><code>{identifier:[a-z]:\*}</code> accepts a string consisting of 0 to infinity lower-case letters.
<li><code>{identifier:[a-z]:+}</code> accepts a string consisting of 1 to infinity lower-case letters.
<li><code>{identifier:[a-z]:?}</code> accepts a string consisting of 0 or 1 lower-case letters.
</ul>

</div>
</details>

</div>
<h2 id="custom-types-and-type-hierarchy">Custom types and type hierarchy</h2>
<p><a href="custom-types.html" target="_blank">Details about custom types</a></p>
<p>It is possible and also common to define custom types. We could e.g. define a type <code>filter-size</code> which consists of a floating point number and a unit (e.g. <code>pixel(s)</code>). In <code>defineSentence</code> we could then use <code>filter-size</code> as type for the standard deviation parameter:</p>
<div class="tab-header"><span>Java</span><span class="selected">Python</span><span>JavaScript</span></div>
<div class="tab-body">
<div class="tab-content selected"><pre><code class="hljs java language-java">parser.defineType(
    <span class="hljs-string">&quot;filter-size&quot;</span>,
    <span class="hljs-string">&quot;{stddev:float} pixel(s)&quot;</span>,
    pn -&gt; pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>));

parser.defineSentence(
    <span class="hljs-string">&quot;Apply Gaussian blurring with a standard deviation of {stddev:filter-size}.&quot;</span>,
    pn -&gt; {
        <span class="hljs-type">double</span> <span class="hljs-variable">stdDev</span> <span class="hljs-operator">=</span> (<span class="hljs-type">double</span>)pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>);
        preprocessing.gaussianBlur((<span class="hljs-type">float</span>)stdDev);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    });</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs python language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluateFilterSize</span>(<span class="hljs-params">pn</span>):
    <span class="hljs-keyword">return</span> pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>)

<span class="hljs-comment"># Create a custom type &#x27;filter-size&#x27;</span>
parser.defineType(
    <span class="hljs-string">&quot;filter-size&quot;</span>,
    <span class="hljs-string">&quot;{stddev:float} pixel(s)&quot;</span>,
    evaluator=evaluateFilterSize)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluateSentence</span>(<span class="hljs-params">pn</span>):
    stddev = pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>)
    preprocessing.gaussianBlur(stddev)

parser.defineSentence(
    <span class="hljs-string">&quot;Apply Gaussian blurring with a standard deviation of {stddev:filter-size}.&quot;</span>,
    evaluator=evaluateSentence)</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs javascript language-javascript">parser.<span class="hljs-title function_">defineType</span>(
  <span class="hljs-string">&quot;filter-size&quot;</span>,
  <span class="hljs-string">&quot;{stddev:float} pixel(s)&quot;</span>,
  <span class="hljs-function"><span class="hljs-params">pn</span> =&gt;</span> pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>));

parser.<span class="hljs-title function_">defineSentence</span>(
  <span class="hljs-string">&quot;Apply Gaussian blurring with a standard deviation of {stddev:filter-size}.&quot;</span>,
  <span class="hljs-function"><span class="hljs-params">pn</span> =&gt;</span> {
    <span class="hljs-keyword">let</span> stdDev = pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>);
    preprocessing.<span class="hljs-title function_">gaussianBlur</span>(stdDev);
    preprocessing.<span class="hljs-title function_">show</span>(<span class="hljs-string">&quot;output&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
  });</code></pre>
</div>
</div>
<p>Find the full code here: <a href="https://github.com/nlScript/nlScript-tutorial-java/blob/main/src/main/java/nlScript/tutorial/preprocessing/Tutorial03.java"><code>Java</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-python/blob/main/tutorial03.py"><code>Python</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-js/blob/main/docs/tutorial03.html"><code>JavaScript</code></a>.</p>
<p>Autocompletion and evaluation will work as before, but the type <code>filter-size</code> can be re-used, e.g. for other filters like the median filter.</p>
<p>Custom types can be defined using built-in types and other custom types. In this way, an entire hierarchy of types can be built up. Here are more <a href="type-hierarchy.html" target="_blank">Details about type hierarchy</a>.</p>
<h2 id="fine-tuning-autocompletion-parameterized-autocompletion">Fine-tuning autocompletion: Parameterized autocompletion</h2>
<p>Defining custom types has an additional advantage: It allows to customize autocompletion. In the example above, with default autocompletion in place, autocompletion looks like</p>
<p><img src="images/Screenshot-01.png" alt="" /></p>
<p>The user sees that a value for the <code>stddev</code> parameter is required, but doesn't know in which units the value needs to be entered. Usage is much clearer if we use inline, or parameterized autocompletion:</p>
<p><img src="images/Screenshot-02.png" alt="" /></p>
<p>This is accomplished by specifying a 4th parameter to <code>defineType</code>, a boolean that specifies whether to use parameterized autocompletion or not (<code>false</code> is the default):</p>
<div class="tab-header"><span>Java</span><span class="selected">Python</span><span>JavaScript</span></div>
<div class="tab-body">
<div class="tab-content selected"><pre><code class="hljs java language-java">parser.defineType(<span class="hljs-string">&quot;filter-size&quot;</span>,
                  <span class="hljs-string">&quot;{stddev:float} pixel(s)&quot;</span>,
                  pn -&gt; pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>),
                  <span class="hljs-literal">true</span>);</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs python language-python">parser.defineType(<span class="hljs-string">&quot;filter-size&quot;</span>,
                  <span class="hljs-string">&quot;{stddev:float} pixel(s)&quot;</span>,
                  <span class="hljs-keyword">lambda</span> pn: pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>),
                  <span class="hljs-literal">True</span>);</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs javascript language-javascript">parser.<span class="hljs-title function_">defineType</span>(<span class="hljs-string">&quot;filter-size&quot;</span>,
                  <span class="hljs-string">&quot;{stddev:float} pixel(s)&quot;</span>,
                  <span class="hljs-function"><span class="hljs-params">pn</span> =&gt;</span> pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>),
                  <span class="hljs-literal">true</span>);</code></pre>
</div>
</div>
<p>Find the full code here: <a href="https://github.com/nlScript/nlScript-tutorial-java/blob/main/src/main/java/nlScript/tutorial/preprocessing/Tutorial04.java"><code>Java</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-python/blob/main/tutorial04.py"><code>Python</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-js/blob/main/docs/tutorial04.html"><code>JavaScript</code></a>.</p>
<h2 id="multiple-choice-autocompletion-choose-a-unit-for-filter-size">Multiple-choice autocompletion: choose a unit for <code>filter-size</code></h2>
<p>Microscope images commonly have a calibrated pixel size, and it is beneficial to specify algorithm parameters in real-world units instead of pixels. This facilitates the re-use of processing workflows, even if images were acquired at different resolutions. To extend the script in this regard, we define another type <code>units</code>. To take different units into account, we can re-define <code>units</code>. Here we will define it as <code>pixel(s)</code> and <code>calibrated units</code> (i.e. the units in which the image is calibrated). If the user selects the first option, we let the <code>units</code> type evaluate to <code>false</code>, otherwise to <code>true</code>.</p>
<div class="tab-header"><span>Java</span><span class="selected">Python</span><span>JavaScript</span></div>
<div class="tab-body">
<div class="tab-content selected"><pre><code class="hljs java language-java">parser.defineType(<span class="hljs-string">&quot;units&quot;</span>, <span class="hljs-string">&quot;pixel(s)&quot;</span>, pn -&gt; <span class="hljs-literal">false</span>);
parser.defineType(<span class="hljs-string">&quot;units&quot;</span>, <span class="hljs-string">&quot;calibrated units&quot;</span>, pn -&gt; <span class="hljs-literal">true</span>);</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs python language-python">parser.defineType(<span class="hljs-string">&quot;units&quot;</span>, <span class="hljs-string">&quot;pixel(s)&quot;</span>, <span class="hljs-keyword">lambda</span> pn:  false)
parser.defineType(<span class="hljs-string">&quot;units&quot;</span>, <span class="hljs-string">&quot;calibrated units&quot;</span>, <span class="hljs-keyword">lambda</span> pn: true)</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs javascript language-javascript">parser.<span class="hljs-title function_">defineType</span>(<span class="hljs-string">&quot;units&quot;</span>, <span class="hljs-string">&quot;pixel(s)&quot;</span>, <span class="hljs-function"><span class="hljs-params">pn</span> =&gt;</span> <span class="hljs-literal">false</span>);
parser.<span class="hljs-title function_">defineType</span>(<span class="hljs-string">&quot;units&quot;</span>, <span class="hljs-string">&quot;calibrated units&quot;</span>, <span class="hljs-function"><span class="hljs-params">pn</span> =&gt;</span> <span class="hljs-literal">true</span>);</code></pre>
</div>
</div>
<p>The definition of <code>filter-size</code> now becomes</p>
<div class="tab-header"><span>Java</span><span class="selected">Python</span><span>JavaScript</span></div>
<div class="tab-body">
<div class="tab-content selected"><pre><code class="hljs java language-java">parser.defineType(<span class="hljs-string">&quot;filter-size&quot;</span>, <span class="hljs-string">&quot;{stddev:float} {units:units}&quot;</span>, pn -&gt; {
    <span class="hljs-type">double</span> <span class="hljs-variable">stddev</span> <span class="hljs-operator">=</span> (Double) pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>);
    <span class="hljs-type">boolean</span> <span class="hljs-variable">units</span> <span class="hljs-operator">=</span> (Boolean) pn.evaluate(<span class="hljs-string">&quot;units&quot;</span>);
    <span class="hljs-keyword">if</span>(units)
        stddev /= image.getCalibration().pixelWidth;
    <span class="hljs-keyword">return</span> stddev;
}, <span class="hljs-literal">true</span>);</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs python language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluateFilterSize</span>(<span class="hljs-params">pn</span>):
    stddev = pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>)
    units = pn.evaluate(<span class="hljs-string">&quot;units&quot;</span>)
    <span class="hljs-keyword">if</span> units:
        stddev /= preprocessing.getPixelWidth()
    <span class="hljs-keyword">return</span> stddev


parser.defineType(<span class="hljs-string">&quot;filter-size&quot;</span>,
                  <span class="hljs-string">&quot;{stddev:float} {units:units}&quot;</span>,
                  evaluateFilterSize,
                  <span class="hljs-literal">True</span>);</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs javascript language-javascript">parser.<span class="hljs-title function_">defineType</span>(<span class="hljs-string">&quot;filter-size&quot;</span>, <span class="hljs-string">&quot;{stddev:float} {units:units}&quot;</span>, pn -&gt; {
    <span class="hljs-keyword">let</span> stddev = pn.evaluate(<span class="hljs-string">&quot;stddev&quot;</span>);
    <span class="hljs-keyword">let</span> units = pn.evaluate(<span class="hljs-string">&quot;units&quot;</span>);
    <span class="hljs-keyword">if</span>(units)
        stddev /= preprocessing.<span class="hljs-title function_">getPixelWidth</span>();
    <span class="hljs-keyword">return</span> stddev;
}, <span class="hljs-literal">true</span>);</code></pre>
</div>
</div>
<p>Find the full code here: <a href="https://github.com/nlScript/nlScript-tutorial-java/blob/main/src/main/java/nlScript/tutorial/preprocessing/Tutorial05.java"><code>Java</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-python/blob/main/tutorial05.py"><code>Python</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-js/blob/main/docs/tutorial05.html"><code>JavaScript</code></a>.</p>
<p>In <code>evaluate()</code> we use <code>pn</code> to retrieve the values for <code>stddev</code> and <code>units</code>. If <code>units</code> evaluates to <code>true</code> (indicating that the user chose <code>calibrated units</code>), we calculate the filter-size in pixels, dividing by the pixel size.</p>
<p>Autocompletion will now look as follows:<br />
<img src="images/Screenshot-03.png" alt="" /><br />
Then, after typing <code>5</code>, followed by <code>tab</code>:<br />
<img src="images/Screenshot-04.png" alt="" /></p>
<h2 id="dynamic-autocompletion-at-runtime-using-a-custom-autocompleter">Dynamic autocompletion at runtime using a custom <code>Autocompleter</code></h2>
<p>The completion option <code>calibrated units</code> obviously does not read very nice. Preferably we would replace it with the actual units the image was calibrated with, e.g. microns. This is runtime dependent, i.e. it depends on the image on which the script is executed. In the code example above, the image is opened before creating the language, but in a more realistic setting, we would like to run our script on any user-selected image.</p>
<p>To replace <code>calibrated units</code> with the real units, we use a custom <code>Autocompleter</code>, which needs to implement the <code>Autocompleter</code> interface:</p>
<div class="tab-header"><span>Java</span><span class="selected">Python</span><span>JavaScript</span></div>
<div class="tab-body">
<div class="tab-content selected"><pre><code class="hljs java language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Autocompleter</span> {
    Autocompletion[] getAutocompletion(ParsedNode pn, <span class="hljs-type">boolean</span> justCheck);
}</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs python language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IAutocompleter</span>(<span class="hljs-title class_ inherited__">ABC</span>):
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getAutocompletion</span>(<span class="hljs-params">self, pn: DefaultParsedNode, justCheck: <span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-type">List</span>[Autocompletion] <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">pass</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Autocompleter</span>(<span class="hljs-title class_ inherited__">IAutocompleter</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, getAutocompletion: <span class="hljs-type">Callable</span>[[ParsedNode, <span class="hljs-built_in">bool</span>], <span class="hljs-type">List</span>[Autocompletion]]</span>):
        self._getAutocompletion = getAutocompletion

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getAutocompletion</span>(<span class="hljs-params">self, pn: ParsedNode, justCheck: <span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-type">List</span>[Autocompletion] <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">return</span> self._getAutocompletion(pn, justCheck)</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs javascript language-javascript">interface <span class="hljs-title class_">Autocompleter</span> {
    <span class="hljs-title function_">getAutocompletion</span>(<span class="hljs-attr">n</span>: <span class="hljs-title class_">DefaultParsedNode</span>, <span class="hljs-attr">justCheck</span>: boolean): <span class="hljs-title class_">Autocompletion</span>[] | <span class="hljs-literal">undefined</span>;
}</code></pre>
</div>
</div>
<p><code>getAutocompletion()</code> returns an array of possible completions. As arguments, it takes a <code>ParsedNode</code>, which can be queried for what's already entered (<code>pn.getParsedString()</code>). A second parameter <code>justCheck</code> indicates that the actual completions are not needed and the function should just return whether it does autocomplete itself (<code>return Autocompletion.doesAutocomplete()</code>) or it leaves autocompletion to its children (<code>return null</code>). This is useful if the calculation of possible completion options is computationally expensive. Normally, <code>getAutocompletion()</code> returns an array of <code>Autocompletion</code>s. There are different subclasses for <code>Autocompletion</code>: <code>Autocompletion.Literal</code> for string constants, <code>Autocompletion.Parameterized</code> for a (single) parametric completion, <code>Autocompletion.EntireSequence</code> for a sequence of literal and parameterized completions, <code>Autocompletion.Veto</code>, which is a special completion which, if present in the list of options, prohibits autocompletion totally. There are several convenience functions to create the different kinds of autocompletions in the <code>Autocompletion</code> class.</p>
<p>In the example at hand, instead of multiple definitions of the type <code>units</code>, we define <code>units</code> to be an arbitrary string that may contain characters <code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>, <code>(</code> and <code>)</code>. Then, we use a custom <code>Autocompleter</code> as a 4th parameter to <code>defineType</code>, which returns as possible autocompletions <code>pixel(s)</code> and the actual string representing the units the open image is calibrated in (<code>imageUnits</code>).</p>
<div class="tab-header"><span>Java</span><span class="selected">Python</span><span>JavaScript</span></div>
<div class="tab-body">
<div class="tab-content selected"><pre><code class="hljs java language-java">parser.defineType(
    <span class="hljs-string">&quot;units&quot;</span>,                                                                <span class="hljs-comment">// the type name</span>
    <span class="hljs-string">&quot;{unitstring:[a-zA-Z()]:+}&quot;</span>,                                            <span class="hljs-comment">// the pattern to parse</span>
    pn -&gt; !pn.getParsedString().equals(<span class="hljs-string">&quot;pixel(s)&quot;</span>),                         <span class="hljs-comment">// the evaluator</span>
    (pn, justCheck) -&gt; Autocompletion.literal(pn, <span class="hljs-string">&quot;pixel(s)&quot;</span>, imageUnits)); <span class="hljs-comment">// the autocompleter</span></code></pre>
</div>
<div class="tab-content"><pre><code class="hljs python language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getAutocompletion</span>(<span class="hljs-params">pn, justCheck</span>):
    <span class="hljs-keyword">return</span> Autocompletion.literal(pn, <span class="hljs-string">&quot;pixel(s)&quot;</span>, imageUnits)

parser.defineType(
    <span class="hljs-string">&quot;units&quot;</span>,                                                                // the <span class="hljs-built_in">type</span> name
    <span class="hljs-string">&quot;{unitstring:[a-zA-Z()]:+}&quot;</span>,                                            // the pattern to parse
    <span class="hljs-keyword">lambda</span> pn: pn.getParsedString() != <span class="hljs-string">&quot;pixel(s)&quot;</span>,                          // the evaluator
    getAutocompletion)                                                      // the autocompleter</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs javascript language-javascript">parser.<span class="hljs-title function_">defineType</span>(
    <span class="hljs-string">&quot;units&quot;</span>,                                                                <span class="hljs-comment">// the type name</span>
    <span class="hljs-string">&quot;{unitstring:[a-zA-Z()]:+}&quot;</span>,                                            <span class="hljs-comment">// the pattern to parse</span>
    <span class="hljs-function"><span class="hljs-params">pn</span> =&gt;</span> pn.<span class="hljs-title function_">getParsedString</span>() !== <span class="hljs-string">&quot;pixel(s)&quot;</span>,                              <span class="hljs-comment">// the evaluator</span>
    <span class="hljs-function">(<span class="hljs-params">pn, justCheck</span>) =&gt;</span> <span class="hljs-title class_">Autocompletion</span>.<span class="hljs-title function_">literal</span>(pn, <span class="hljs-string">&quot;pixel(s)&quot;</span>, imageUnits)); <span class="hljs-comment">// the autocompleter</span></code></pre>
</div>
</div>
<p><code>Autocompletion.literal</code> creates an array of literal completions from a <code>ParsedNode</code> and a variable number of <code>String</code> arguments.</p>
<p>So where does <code>imageUnits</code> come from? We need to catch it at runtime, so we register a <code>ParseStartListener</code> on the <code>parser</code>, and read the image calibration units at the time parsing is started:</p>
<div class="tab-header"><span>Java</span><span class="selected">Python</span><span>JavaScript</span></div>
<div class="tab-body">
<div class="tab-content selected"><pre><code class="hljs java language-java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">imageUnits</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
parser.addParseStartListener(() -&gt; {
    imageUnits.setLength(<span class="hljs-number">0</span>);
    imageUnits.append(image.getCalibration().getUnits());
});</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs python language-python">imageUnits = <span class="hljs-string">&quot;&quot;</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">parsingStarted</span>():
    <span class="hljs-keyword">global</span> imageUnits
    imageUnits = preprocessing.getUnits()

parser.addParseStartListener(listener=ParseStartListener(parsingStarted))</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> imageUnits = <span class="hljs-string">&quot;&quot;</span>;
parser.<span class="hljs-title function_">addParseStartListener</span>(<span class="hljs-function">() =&gt;</span> {
  imageUnits = preprocessing.<span class="hljs-title function_">getUnits</span>();
});</code></pre>
</div>
</div>
<p>Find the full code here: <a href="https://github.com/nlScript/nlScript-tutorial-java/blob/main/src/main/java/nlScript/tutorial/preprocessing/Tutorial06.java"><code>Java</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-python/blob/main/tutorial06.py"><code>Python</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-js/blob/main/docs/tutorial06.html"><code>JavaScript</code></a>.</p>
<p>Once autocompletion hits the <code>units</code> phrase, it displays a dropdown menu with the 2 options <code>pixel(s)</code> and <code>mm</code>, as desired.</p>
<h2 id="prohibit-further-autocompletion-autocompleterveto">Prohibit further autocompletion: <code>Autocompleter.VETO</code></h2>
<p>However, when we start typing a value for <code>units</code>, e.g. we manually enter <code>cm</code>, it still shows <code>pixel(s)</code>, <code>mm</code> and additionally <code>.</code>. That's because our <code>Autocompleter</code> always returns the two options. We could decide to just skip autocompletion once the user starts to type. We can do this in the <code>Autocompleter</code>, by checking if the user already entered something, and in case s/he did, we return <code>Autocompletion.veto()</code>:</p>
<div class="tab-header"><span>Java</span><span class="selected">Python</span><span>JavaScript</span></div>
<div class="tab-body">
<div class="tab-content selected"><pre><code class="hljs java language-java">parser.defineType(
    <span class="hljs-string">&quot;units&quot;</span>,
    <span class="hljs-string">&quot;{unitstring:[a-zA-Z()]:+}&quot;</span>,
    pn -&gt; !pn.getParsedString().equals(<span class="hljs-string">&quot;pixel(s)&quot;</span>),
    (pn, justCheck) -&gt; pn.getParsedString().isEmpty()
                        ? Autocompletion.literal(pn, <span class="hljs-string">&quot;pixel(s)&quot;</span>, imageUnits)
                        : Autocompletion.veto(pn));</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs python language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getAutocompletion</span>(<span class="hljs-params">pn, justCheck</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pn.getParsedString()) == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> Autocompletion.literal(pn, [<span class="hljs-string">&quot;pixel(s)&quot;</span>, imageUnits])
    <span class="hljs-keyword">return</span> Autocompletion.veto(pn)

parser.defineType(
    <span class="hljs-string">&quot;units&quot;</span>,
    <span class="hljs-string">&quot;{unistring:[a-zA-Z()]:+}&quot;</span>,
    <span class="hljs-keyword">lambda</span> pn: pn.getParsedString() != <span class="hljs-string">&quot;pixel(s)&quot;</span>,
    getAutocompletion)</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs javascript language-javascript">parser.<span class="hljs-title function_">defineType</span>(
    <span class="hljs-string">&quot;units&quot;</span>,
    <span class="hljs-string">&quot;{unitstring:[a-zA-Z()]:+}&quot;</span>,
    <span class="hljs-function"><span class="hljs-params">pn</span> =&gt;</span> pn.<span class="hljs-title function_">getParsedString</span>() !== <span class="hljs-string">&quot;pixel(s)&quot;</span>,
    <span class="hljs-function">(<span class="hljs-params">pn, justCheck</span>) =&gt;</span> pn.<span class="hljs-title function_">getParsedString</span>().<span class="hljs-property">length</span> === <span class="hljs-number">0</span>
        ? nlScript.<span class="hljs-property">Autocompletion</span>.<span class="hljs-title function_">literal</span>(pn, [<span class="hljs-string">&quot;pixel(s)&quot;</span>, imageUnits])
        : nlScript.<span class="hljs-property">Autocompletion</span>.<span class="hljs-title function_">veto</span>(pn));</code></pre>
</div>
</div>
<p>Find the full code here: <a href="https://github.com/nlScript/nlScript-tutorial-java/blob/main/src/main/java/nlScript/tutorial/preprocessing/Tutorial07.java"><code>Java</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-python/blob/main/tutorial07.py"><code>Python</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-js/blob/main/docs/tutorial07.html"><code>JavaScript</code></a>.</p>
<h2 id="dynamically-re-defining-types">Dynamically re-defining types</h2>
<p>The above solution works, but the meaning is a little different from what we wanted to achieve originally. Although it shows <code>pixel(s)</code> and <code>mm</code> as completion options, it accepts any string (we defined the pattern to parse to be <code>a-zA-Z()</code>). In fact, we'd ideally like to restrict possible types to <code>pixel(s)</code> and <code>mm</code>. And we can implement this by dynamically changing the parser, i.e. re-defining the type <code>units</code>. We do this again with a <code>ParseStartListener</code>:</p>
<div class="tab-header"><span>Java</span><span class="selected">Python</span><span>JavaScript</span></div>
<div class="tab-body">
<div class="tab-content selected"><pre><code class="hljs java language-java">parser.addParseStartListener(() -&gt; {
    <span class="hljs-type">String</span> <span class="hljs-variable">unitsString</span> <span class="hljs-operator">=</span> image.getCalibration().getUnits();

    parser.undefineType(<span class="hljs-string">&quot;units&quot;</span>);

    <span class="hljs-comment">// Re-define the &#x27;units&#x27; type</span>
    parser.defineType(<span class="hljs-string">&quot;units&quot;</span>, <span class="hljs-string">&quot;pixel(s)&quot;</span>, pn -&gt; <span class="hljs-literal">false</span>);
    parser.defineType(<span class="hljs-string">&quot;units&quot;</span>, unitsString, pn -&gt; <span class="hljs-literal">true</span>);
});</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs python language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">parsingStarted</span>():
    unitsString = preprocessing.getUnits()

    parser.undefineType(<span class="hljs-string">&quot;units&quot;</span>)

    <span class="hljs-comment"># Re-define the &#x27;units&#x27; type</span>
    parser.defineType(<span class="hljs-string">&quot;units&quot;</span>, <span class="hljs-string">&quot;pixel(s)&quot;</span>, <span class="hljs-keyword">lambda</span> pn: <span class="hljs-literal">False</span>)
    parser.defineType(<span class="hljs-string">&quot;units&quot;</span>, unitsString, <span class="hljs-keyword">lambda</span> pn: <span class="hljs-literal">True</span>)


parser.addParseStartListener(listener=ParseStartListener(parsingStarted))</code></pre>
</div>
<div class="tab-content"><pre><code class="hljs javascript language-javascript">parser.<span class="hljs-title function_">addParseStartListener</span>(<span class="hljs-function">() =&gt;</span> {
    imageUnits = preprocessing.<span class="hljs-title function_">getUnits</span>();

    parser.<span class="hljs-title function_">undefineType</span>(<span class="hljs-string">&quot;units&quot;</span>);

    <span class="hljs-comment">// Re-define the &#x27;units&#x27; type</span>
    parser.<span class="hljs-title function_">defineType</span>(<span class="hljs-string">&quot;units&quot;</span>, <span class="hljs-string">&quot;pixel(s)&quot;</span>, <span class="hljs-function"><span class="hljs-params">pn</span> =&gt;</span> <span class="hljs-literal">false</span>);
    parser.<span class="hljs-title function_">defineType</span>(<span class="hljs-string">&quot;units&quot;</span>, imageUnits, <span class="hljs-function"><span class="hljs-params">pn</span> =&gt;</span> <span class="hljs-literal">true</span>);
});</code></pre>
</div>
</div>
<p>Find the full code here: <a href="https://github.com/nlScript/nlScript-tutorial-java/blob/main/src/main/java/nlScript/tutorial/preprocessing/Tutorial08.java"><code>Java</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-python/blob/main/tutorial08.py"><code>Python</code></a> <a href="https://github.com/nlScript/nlScript-tutorial-js/blob/main/docs/tutorial08.html"><code>JavaScript</code></a>.</p>
<p>This does now exactly what we wanted, i.e. it acts like the <code>units</code> type was defined from the beginning on with the calibration unit of the image.</p>
<p>This is indeed a very powerful feature, as it allows for dynamic re-definition of the parsed language, based on current runtime circumstances.</p>
<p><br><br />
<br><br />
<br></p>
<script>

let selectedTab = 0;

tabHeaders = document.getElementsByClassName("tab-header");
for(tabHeader of tabHeaders) {
  let tabBody = tabHeader.nextElementSibling;
  console.log("tabBody");
  console.log(tabBody);
  for(let i = 0; i < tabHeader.children.length; i++) {
    tabHeader.children[i].onclick = clickTab;
    if(i == selectedTab) {
      console.log("Clicked tab " + i);
      tabHeader.children[i].classList.add('selected');
      tabBody.children[i].classList.add('selected');
    } else {
      console.log("Did not click tab " + i);
      tabHeader.children[i].classList.remove('selected');
      tabBody.children[i].classList.remove('selected');
    }
  }
}
</script></article>
